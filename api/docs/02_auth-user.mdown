Title: Obtaining a User Access Token

Before you can request an access token for a user, your client application must be registered in order to receive an `app_token` and `app_secret`.

This authentication flow is often referred to as *3-legged OAuth2*. We recommend using an [existing client library](http://oauth.net/2/) to connect. 


# 1. Redirect user to login page

Within your application, direct the user to `https://api.inboxapp.com/a/login` with the URL parameters below.
    
* `email_address` —  the user's email address
* `client_id` — your application's token [insert here]
* `redirect_uri`
* `response_type` must be `code`
* `scope` — array of scopes you are reqeusting. Must include at least one. Options are `mail`, `contacts`, and `files`.
* `state` — optional unique identifier to protect against CSRF

Depending on the user's email provider, Inbox will either direct them to Gmail's OAuth page or request their email account credentials directly.

    [[ Screenshot here, both Gmail and Exchange]]




# 2. Received authenticated callback Inbox

Once the user has provided their account credentials, Inbox will redirect to `CALLBACK_URL?code=CODE` specified in your application's settings. 

If you provided the `state` parameter above, it will also be included as a url parameter.

**Note: Inbox only supports HTTPS.** This means that your `CALLBACK_URL` must be secured behind HTTPS. Additonally, any request to `http://api.inboxapp.com` will fail. 

Seriously. Port 80 is actually closed on the API servers. We know this isn't an ideal developer experience, but absolute security for users is the most important thing here. 

For development environments, we recommend proxying HTTPS traffic to your application with [stunnel](https://www.stunnel.org/index.html) and a self-signed SSL certificate. By default, Inbox does not attempt to verify the certificate chain. 


# 3. Request `access_token`

After receiving the callback in step2, your application should exchange `code` for an `access_token`. 

    POST https://api.inboxapp.com/a/token
    
  with the URL parameters
  
  * `grant_type` as the string `authorization_code`
  * `code` is the value returned in step 2
  * `redirect_uri` same as previously used
  * `client_id` as your application's token
  * `client_secret` as your application's secret



If `client_id` and `client_secret` are valid, server will invoke a callback on `redirect_url` that contains an `access_token` in the form:

```
:::json
{
    "access_token": "...",
    "refresh_token": "...",
    "token_type": "bearer",
    "expire_in": 7200,
    "scope": "..."
}   
```


Store these values. You can now use the `access_token` to initiate Inbox API requests for the authenticated user.


# 4. Refreshing the `access_token`

The `access_token` returned in step 3 has a limited lifetime, denoted by the `expire_in` paramter. 

This is done because the `access_token` may frequently be exposed on the wire, but if snooped, the snooper has only brief access and cannot extend the access period. The refresh token is exposed less often, but is valid for a long time. It's like a client-specific revocable subpassword.

If an expired token is used for an API request, the server will respond with an error. This means your application must use the `refresh_token` to request a new `access_token`. 

    POST https://api.inboxapp.com/a/token
        
  with the URL parameters
  
  * `grant_type` must be `refresh_token`
  * `refresh_token` as the stored value
  * `client_id`
  * `client_secret`
  * `scope` (optional) the previously requested scopes. If you application needs to request additional scopes, you will need to restart the OAuth process. 

If all parameters are valid, the server will invoke a callback on `redirect_url` that contains a new `access_token` in the form:

```
:::json
{
    "access_token": "...",
    "refresh_token": "...",
    "token_type": "bearer",
    "expire_in": 7200,
    "scope": "..."
}   
```

