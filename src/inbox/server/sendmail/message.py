"""
When sending mail, Inbox tries to be a good citizen to the modern world.
This means everything we send is either ASCII or UTF-8.
That means no Latin-1 or ISO-8859-1.

All headers are converted to ASCII and if that doesn't work, UTF-8.

Note that plain text that's UTF-8 will be sent as base64. i.e.:
Content-Type: text/text; charset='utf-8'
Content-Transfer-Encoding: base64

This is because not all servers support 8BIT and so flanker drops to b64.
http://www.w3.org/Protocols/rfc1341/5_Content-Transfer-Encoding.html

"""
import uuid
import pkg_resources
from collections import namedtuple
from datetime import datetime

from flanker import mime
from flanker.addresslib import address
from html2text import html2text

from inbox.server.crispin import RawMessage
from inbox.server.mailsync.backends.base import create_db_objects, commit_uids
from inbox.server.mailsync.backends.imap.account import create_gmail_message

VERSION = pkg_resources.get_distribution('inbox').version

SenderInfo = namedtuple('SenderInfo', 'name email')
SMTPMessage = namedtuple('SMTPMessage', 'uid msg recipients thread_id')


def create_email(sender_info, recipients, subject, html, attachments):
    """
    Creates a MIME email message (both body and sets the needed headers).

    Parameters
    ----------
    sender_info : SenderInfo(name, email)
    recipients : list
        a list of utf-8 encoded strings
    subject : string
        a utf-8 encoded string
    body : string
        a utf-8 encoded string
    attachments: list, optional
        a list of filenames

    """
    full_name = sender_info.name if sender_info.name else ''
    email_address = sender_info.email
    to = address.parse_list(recipients.to)
    cc = address.parse_list(recipients.cc)
    bcc = address.parse_list(recipients.bcc)
    plaintext = html2text(html)

    # Create a multipart/alternative message
    msg = mime.create.multipart('alternative')
    msg.append(
        mime.create.text('text', plaintext),
        mime.create.text('html', html))

    # Create an outer multipart/mixed message
    if attachments:
        text_msg = msg
        msg = mime.create.multipart('mixed')

        # The first part is the multipart/alternative text part
        msg.append(text_msg)

        # The subsequent parts are the attachment parts
        for a in attachments:
            # Disposition should be inline if we add Content-ID
            msg.append(mime.create.attachment(
                a['content_type'],
                a['data'],
                filename=a['filename'],
                disposition='attachment'))

    msg.headers['Subject'] = subject

    # Gmail sets the From: header to the default sending account. We can
    # however set our own custom phrase i.e. the name that appears next to the
    # email address (useful if the user has multiple aliases and wants to
    # specify which to send as), see: http://lee-phillips.org/gmailRewriting/
    # For other providers, we simply use full_name = ''
    from_addr = u'"{0}" <{1}>'.format(full_name, email_address)
    from_addr = address.parse(from_addr)
    msg.headers['From'] = from_addr.full_spec()

    # We need to set these headers so recipients know we sent the email to them:

    # Note also that the To: header has different semantics than the envelope
    # recipient. For example, you can use '"Tony Meyer" <tony.meyer@gmail.com>'
    # as an address in the To: header, but the envelope recipient must be only
    # 'tony.meyer@gmail.com'.
    msg.headers['To'] = u', '.join([addr.full_spec() for addr in to])
    msg.headers['Cc'] = u', '.join([addr.full_spec() for addr in cc])
    msg.headers['Bcc'] = u', '.join([addr.full_spec() for addr in bcc])

    # Add our custom Inbox headers
    add_custom_headers(msg)

    return msg


def add_custom_headers(msg):
    """
    Set a custom `X-INBOX-ID` header so as to identify messages generated by
    Inbox.

    The header is set to a unique id generated randomly per message,
    and is needed for the correct reconciliation of sent messages on
    future syncs.

    Notes
    -----
    We use uuid.uuid4().hex to generate the UUID as a 32-character hexadecimal
    string (random, does not compromise privacy).

    """

    # Set our own custom header for tracking in `Sent Mail` folder
    msg.headers['X-INBOX-ID'] = str(uuid.uuid4().hex)

    # Potentially also use `X-Mailer`
    msg.headers['User-Agent'] = 'Inbox/{0}'.format(VERSION)


def add_reply_headers(replyto, msg):
    """ Add reply specific headers. """
    # Set the In-Reply-To header of the reply:
    msg.headers['In-Reply-To'] = replyto.message_id

    # Set the 'References' header of the reply:
    separator = '\t'
    msg.headers['References'] = replyto.references + separator + replyto.message_id

    return msg


def smtp_attrs(msg, thread_id=None):
    """ Generate the SMTP recipients, RFC compliant SMTP message. """
    # SMTP recipients include addresses in To-, Cc- and Bcc-
    all_recipients = u', '.\
        join([m for m in msg.headers.get('To'),
             msg.headers.get('Cc'),
             msg.headers.get('Bcc') if m])

    recipients = [a.full_spec() for a in address.parse_list(all_recipients)]

    # Keep Cc-, but strip Bcc-
    # TODO[k]: We actually want to keep Bcc- on the bcc- recipients (only!) but
    # for now, we strip for all.
    msg.remove_headers('Bcc')

    # Create an RFC compliant SMTP message
    rfcmsg = rfc_transform(msg)

    smtpmsg = SMTPMessage(uid=msg.headers.get('X-INBOX-ID'),
                          msg=rfcmsg,
                          recipients=recipients,
                          thread_id=thread_id)

    return smtpmsg


def rfc_transform(msg):
    """ Create an RFC compliant SMTP message. """
    msgstring  = msg.to_string()

    start = msgstring.find('References: ')

    if start == -1:
        return msgstring

    end = msgstring.find('\r\n', start+len('References: '))

    substring = msgstring[start:end]

    separator = '\n\t'
    rfcmsg = msgstring[:start] + substring.replace('\t', separator) + msgstring[end:]

    return rfcmsg


def create_gmail_email(sender_info, recipients, subject, body,
        attachments=None):
    """ Create a Gmail email. """
    mimemsg = create_email(sender_info, recipients, subject, body, attachments)

    return smtp_attrs(mimemsg)


def create_gmail_reply(replyto, sender_info, recipients, subject, body,
        attachments=None):
    """ Create a Gmail email reply. """
    mimemsg = create_email(sender_info, recipients, subject, body, attachments)

    # Add general reply headers:
    reply = add_reply_headers(replyto, mimemsg)

    # Set the 'Subject' header of the reply, required for Gmail.
    # Gmail requires the same subject as the original (adding Re:/Fwd: is fine
    # though) to group them in the same conversation,
    # See: https://support.google.com/mail/answer/5900?hl=en
    replystr = 'Re: '
    reply.headers['Subject'] = replystr + replyto.subject

    return smtp_attrs(reply, replyto.thread_id)


def save_gmail_email(account_id, db_session, log, smtpmsg):
    # TODO[k]: Check these -
    uid = uuid.uuid4().int & (1 << 16) - 1

    date = datetime.utcnow()
    folder_name = 'sent'

    msg = RawMessage(uid=uid, internaldate=date, flags=set(),
                     body=smtpmsg.msg, g_thrid=smtpmsg.thread_id,
                     g_msgid=None, g_labels=set(), created=True)
    new_uids = create_db_objects(account_id, db_session, log, folder_name,
                                 [msg], create_gmail_message)

    assert len(new_uids) == 1
    new_uids[0].created_date = date

    commit_uids(db_session, log, new_uids)

    return new_uids[0]
